
	include "nesdefs.dasm"

; maybe change the item types 00 for objects 10 for dirt

;;;;; VARIABLES

lvlptr	= $0

func0	= $2
func1	= $3
func2	= $4
func3	= $5
func4	= $6
func5	= $7
func6	= $8
func7	= $9

tmp0	= $a
tmp1	= $b
tmp2	= $c
tmp3	= $d
tmp4	= $e
tmp5	= $f

lvl	= $10
jtimer	= $11 ; jump timer
Flags	= $12

px0	= $20
px1	= $21
px2	= $22
vx0	= $23
vx1	= $24
vx2	= $25
ax0	= $26
ax1	= $27
ax2	= $28

py0	= $29 ; in relation to other objects on the screen, doesn't account for scroll
py1	= $2A
py2	= $2B
vy0	= $2C
vy1	= $2D
vy2	= $2E
ay0	= $2F
ay1	= $30
ay2	= $31

angle0	= $32	; angle from the hook. 24 bit (should be 16?)
angle1	= $33
angle2	= $34
omega0	= $35	; angular momentum. 24 bit (should be 16?)
omega1	= $36
omega2	= $37
relpx0	= $38	; x and y distance from the hook. 8 bit
relpy0	= $39
radius	= $3A	; radius from the hook. 8 bit (but actually 7)
hookpx	= $3B	; hook pixel position. 8 bit
hookpy	= $3C
hookidx	= $3D	; hook index in oam dma
scroll	= $3E	; screen scroll. [0, 240]

; $40-$5F are the same from last frame

lvldat	= $60

objlist	= $80
collist	= $a8

;; Physics Constants
GRAVITY	        = $006000
MAX_FALL	= $056010
JUMP_FORCE	= $030000
WALK_ACCEL	= $006a80
MAX_WALK	= $015000
PASSIVE_DECEL	= $003540
HOOK_SWING	= 60
HOOK_RANGE	= 60
MAX_JUMP	= 9
MARGIN		= $8
WIDTH		= $5
HEIGHT		= $7
SIN_HEAD	= $a0
PYTAN_HEAD	= $e0
LEVEL_HEAD	= $98
SCROLL_THOLD	= 60
SCREEN_HEIGHT	= 240
SCREEN_WIDTH	= 256

	org $0

	;;; HEADER
        
	NES_HEADER 0,2,1,0 ; mapper 0, 2 PRGs, 1 CHR, horiz. mirror


	
        ;;; INIT

Start:
	; wait for PPU warmup, clear CPU RAM
	NES_INIT
        jsr WaitSync
        jsr ClearRAM
        jsr WaitSync
       
       
        ; ppu setup
        jsr LoadPallete
        
        lda #0
        sta PPU_SCROLL
        sta PPU_SCROLL
                      
        lda #0
        sta OAM_ADDR

	; load level
        sta lvl
	sta lvlptr
        lda #LEVEL_HEAD
        sta lvlptr+1
        jsr LoadLevel
        jsr RenderLevel

        ; enable rendering, nmi
        lda #$80
        sta PPU_CTRL
        lda #$1e
        sta PPU_MASK
        
        lda #0
        sta PPU_ADDR
        sta PPU_ADDR       
        
        ; sprite setup        
        lda #$10
        sta $201
        lda #0
        sta $202
        
        ; initial values
        lda #70
        sta px0
        lda #70
        sta py0
        
        lda #$0
        sta px1
        sta py1

	lda #$0
        sta vx1
        sta vx0
        sta vx2
        
        lda #$0
        sta vy0  

        lda #0
        sta scroll
        jsr UpdateSprites

  

	;;; MAIN GAME LOGIC

.endless
        jmp .endless


NMIHandler:
     	; Update the PPU in VBlank
        lda #0
        sta PPU_SCROLL
        
        ; disable nmi, set nametable
        ldx #$00
        lda scroll
        cmp #240
        bcc .notend
        lda #0
        ldx #$02
.notend
        sta PPU_SCROLL
        stx PPU_CTRL

	; set hero sprite
        lda py0
        clc
        adc scroll
        lda py0
        bcc .topscreen
	adc #7
.topscreen
        sec
        sbc #5
        sta $200     
        lda px0
        sec
        sbc #4
        sta $203
        
        ; draw sprites
        lda #02
        sta PPU_OAM_DMA
	       
        ; read controller
	include "readpad.asm" 
 
	; backup variables from last frame
	ldx #$1f
.copyold
	lda $20,x
        sta $40,x
        dex
        bpl .copyold

	; do physics calculations based on mode
	lda #$80
        bit Flags
        bne .hook
        jsr NormalMode
        jmp .physdone
.hook
	jsr HookMode
.physdone


	; scroll the screen if needed
	include "scroll.asm"
        
NMIEnd:    
	; enable nmi, set nametable
        ldx #$80
        lda scroll
        cmp #240
        bcc .notend2
        ldx #$82
.notend2
	ldy PPU_STATUS
        stx PPU_CTRL
        
        rti




        ;;; SUBROUTINES
                
LoadPallete:
	PPU_SETADDR $3f00
        ldx #$0
.ld_l   lda Pallete,x
        sta PPU_DATA
        inx
        cpx #$20
        bne .ld_l
        rts

        ; reverses horizontal acceleration
NegativeAclX:
	clc
        lda ax2
        eor #$ff
        adc #1
        sta ax2
        lda ax1
        eor #$ff
        adc #0
        sta ax1
        lda ax0
        eor #$ff
        adc #0
        sta ax0
        rts
        

        include "physics.asm"
	include "hookmode.asm"     
	include "math.asm"
	include "level.asm"
        
ClearRAM: subroutine
	lda #0
        tax
.clearRAM
	sta $0,x	; clear $0-$ff
        cpx #$fe	; last 2 bytes of stack?
        bcs .skipStack	; don't clear it
	sta $100,x	; clear $100-$1fd
.skipStack
	sta $200,x	; clear $200-$2ff
	sta $300,x	; clear $300-$3ff
	sta $400,x	; clear $400-$4ff
	sta $500,x	; clear $500-$5ff
	sta $600,x	; clear $600-$6ff
	sta $700,x	; clear $700-$7ff
        inx		; X = X + 1
        bne .clearRAM	; loop 256 times
        rts

	; wait for VSYNC to start
WaitSync:
	bit PPU_STATUS
	bpl WaitSync
        rts

DrawObjects: subroutine
	ldx #0
        lda objlist,x
                
        iny
        lda $5
        rol
        rol
        rol
        rol
        and #$7
        ora #$80
        sta $0280,y
        iny	; temporary. do stuff here later
        iny
        inx
        
        lda $5
        clc
        asl
        asl
        asl
        sta $0280,y
        clc
        adc #4
        rts



        ;;; DATA

Pallete:
	.hex 3b
        .hex 0b1a07 00
        .hex 0b1a07 00
        .hex 0b1a07 00
        .hex 0b1a07 3b
        .hex 04130d 00
        .hex 000000 00
        .hex 000000 00
        .hex 000000 00

	org LEVEL_HEAD<<8
        .byte $87, $2b, $87, $36, 20, 12, $23, 40, 24, $26,  23, 17, $23, 25, 22, $23
        .byte 17, 10, $23
        .byte $a2, $2b, $c, $5, $24, 27, 18, $23, $86, $26, 54, 1, $1e, 54, $f, $1f
        .byte $0
        


        ; math look up tables
        org SIN_HEAD<<8
        include "sinetable.asm"    
	include "pythtantable.asm"



	;;; VECTORS
        
	NES_VECTORS



	;;; CHR ROM
CHR:
	incbin "chars.chr"